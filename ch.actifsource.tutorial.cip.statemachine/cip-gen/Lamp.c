
/*********************************************************************
	SYSTEM System1
	Module for PROCESS Lamp
	Filename: Lamp.c
	generated by CIP Tool(R) Version 1.0.0
	
	activated code options:
		C code
		use channel interface
			naming option: use default prefix
		'unsigned long' for delays
*********************************************************************/

/* Include Files */

#include "mLamp.h"

/* Process Macro Definitions */

#define SELF status_Lamp.write_access_
#define STATUS (pStatus_Lamp->read_access_)
#define TIME time_

/* Process Enumerations */

enum eMODES_Lamp
	{normal = 1};

enum eSTATES_Lamp
	{Bright = 1, Dark, Delayed};

enum eINPULS_Lamp
	{IP_On = 1, IP_Off = 2, TIMEUP_ = 3};

/* External Declarations */

extern unsigned long time_;
extern struct tTMQE_mLamp *tuhead_mLamp, *tutail_mLamp;
extern struct tCHNOUT_mLamp CHNOUT_mLamp;
extern struct tTIMING_mLamp TIMING_mLamp;



void fSETTIM_mLamp (unsigned long *delay_, struct tTMEL_mLamp *timer_, struct tTMQE_mLamp *timeup_);
void fSTOPTIM_mLamp (struct tTMEL_mLamp *timer_, struct tTMQE_mLamp *timeup_);

/* Global Declarations */

static unsigned long delay_;
struct tPRINST_Lamp IO_Lamp;
union tSTATUS_Lamp status_Lamp;
const union tSTATUS_Lamp *pStatus_Lamp = &status_Lamp;

/* Function Prototypes */

int fPULSE_Lamp (enum eOUTPLS_ name_);
void fINIT_Lamp (void);

/* Input Channel Functions */

int fPULSE_Lamp (enum eOUTPLS_ name_)
{
	switch(name_)
	{
		/* INPULSE On */
	case O1_On:		/* PULSE CAST from PROCESS Button */
		switch(status_Lamp.read_access_.STATE)
		{
		case Dark:
			status_Lamp.write_access_.STATE = Bright;
			CHNOUT_mLamp.message_.CHAN_Lamp.name_ = C1_Bright;
			OUT_.Lamp(CHNOUT_mLamp.message_.CHAN_Lamp.name_);
			break;
		case Delayed:
			status_Lamp.write_access_.STATE = Bright;
			fSTOPTIM_mLamp(&IO_Lamp.timer_, 
				&IO_Lamp.timeup_);
			break;
		default:
			break;
		}
		break;
		/* INPULSE Off */
	case O1_Off:		/* PULSE CAST from PROCESS Button */
		switch(status_Lamp.read_access_.STATE)
		{
		case Bright:
			status_Lamp.write_access_.STATE = Delayed;
			fSETTIM_mLamp(&delay_, 
				&IO_Lamp.timer_, 
				&IO_Lamp.timeup_);
			break;
		default:
			break;
		}
		break;
	default:
		return 0;
	}
	return 1;
}

/* Timer Functions */

static void fTICK_Lamp (void)
{
	if (IO_Lamp.timer_.set_ &&
		IO_Lamp.timer_.end_ == time_)
	{
		IO_Lamp.timer_.set_ = FALSE;
		--TIMING_mLamp.set_;
		if (tuhead_mLamp != &IO_Lamp.timeup_ &&
			!IO_Lamp.timeup_.preced_ &&
			!IO_Lamp.timeup_.next_)
		{
			if (!tuhead_mLamp)
			{
				tuhead_mLamp = tutail_mLamp = &IO_Lamp.timeup_;
			}
			else
			{
				tutail_mLamp->next_ = &IO_Lamp.timeup_;
				IO_Lamp.timeup_.preced_ = tutail_mLamp;
				tutail_mLamp = &IO_Lamp.timeup_;
			}
		}
	}			
}

static void fTUHNDL_Lamp(void)
{
	struct tTMQE_mLamp *element_ = tuhead_mLamp;
	if (tuhead_mLamp == tutail_mLamp)
	{
		tuhead_mLamp = tutail_mLamp = 0;
	}
	else 
	{
		tuhead_mLamp = element_->next_;
		element_->next_ = 0;
		tuhead_mLamp->preced_ = 0;
	}
	switch(status_Lamp.read_access_.STATE)
	{
	case Delayed:
		status_Lamp.write_access_.STATE = Dark;
		CHNOUT_mLamp.message_.CHAN_Lamp.name_ = C1_Dark;
		OUT_.Lamp(CHNOUT_mLamp.message_.CHAN_Lamp.name_);
		break;
	default:
		break;
	}
}

/* Process Initialization Function */

void fINIT_Lamp (void)
{
	status_Lamp.write_access_.STATE = Dark;
	IO_Lamp.timer_.set_ = FALSE;
	IO_Lamp.timeup_.preced_ = 0;
	IO_Lamp.timeup_.next_ = 0;
	IO_Lamp.timeup_.proctype_ = 0;
	TIMING_mLamp.tkhndl_ = fTICK_Lamp;
	TIMING_mLamp.tuhndl_ = fTUHNDL_Lamp;
}		

/*********************************************************************
	End of Module for PROCESS Lamp
*********************************************************************/
// Actifsource ID=[e9267837-2596-11e1-ae2f-a14f3e396de6,c78073c1-af0f-11e1-8e28-c3261f5498f2,4971106d-af26-11e1-8e28-c3261f5498f2,ba697f7b-2723-11e1-b14b-53cb3f44a5b8,4977c731-af26-11e1-8e28-c3261f5498f2,4a6d2879-af14-11e1-8e28-c3261f5498f2,52e93f6b-af14-11e1-8e28-c3261f5498f2,kp9BsVycyDGaOiILrPmuYhZ9h1U=]
