
/*********************************************************************
	SYSTEM System1
	IMPLEMENTATION Lamp
	Module for CIP MACHINE mLamp
	Filename: mLamp.c
	generated by CIP Tool(R) Version 1.0.0
	
	activated code options:
		C code
		use channel interface
			naming option: use default prefix
		'unsigned long' for delays
*********************************************************************/

/* Include Files */

#include "mLamp.h"

/* External Declarations */

void fICHAN_Button (enum eMSG_Button name_);
void fINIT_Button (void);
void fINIT_Lamp (void);

/* Global Declarations */

unsigned long time_ = 0;
struct tCHNOUT_mLamp CHNOUT_mLamp;
struct tTIMING_mLamp TIMING_mLamp;
struct tTMQE_mLamp *tuhead_mLamp, *tutail_mLamp;

/* Function Prototypes */

void fSETTIM_mLamp (unsigned long *delay_, struct tTMEL_mLamp *timer_, struct tTMQE_mLamp *timeup_);
void fSTOPTIM_mLamp (struct tTMEL_mLamp *timer_, struct tTMQE_mLamp *timeup_);
void fSTEP_(void);
void fCHAIN_(void);
void fTIMEUP_(void);
void fREAD_(void);

/* AUTO_ Handler Function */

static void fAUTOHDL_(void)
{
		/* dummy function handling no AUTO_ */
}

/* Timer Functions */

static void fTICK_(void)
{
	++time_;
	if (TIMING_mLamp.set_)
	{
		TIMING_mLamp.tkhndl_();
	}
}

void fSETTIM_mLamp (unsigned long *delay_, struct tTMEL_mLamp *timer_, struct tTMQE_mLamp *timeup_)
{
	if (*delay_ > 0)
	{
		if (!timer_->set_)
		{
			++TIMING_mLamp.set_;
		}
		timer_->set_ = TRUE;
		timer_->end_ = time_ + *delay_;
		if (tuhead_mLamp == timeup_)
		{
			tuhead_mLamp = tuhead_mLamp->next_;
		}
		if (timeup_->preced_)
		{
			timeup_->preced_->next_ = timeup_->next_;
		}
		if (timeup_->next_)
		{
			timeup_->next_->preced_ = timeup_->preced_;
		}
		if (tutail_mLamp == timeup_)
		{
			tutail_mLamp = timeup_->preced_;
		}
		timeup_->preced_ = 0;
		timeup_->next_ = 0;
	}
	else 
	{
		if (timer_->set_)
		{
			--TIMING_mLamp.set_;
		}
		timer_->set_ = FALSE;
		if (tuhead_mLamp != timeup_ && ! timeup_->preced_ && ! timeup_->next_)
		{
			if (!tuhead_mLamp)
			{
				tuhead_mLamp = tutail_mLamp = timeup_;
			}
			else 
			{
				tutail_mLamp->next_ = timeup_;
				timeup_->preced_ = tutail_mLamp;
				tutail_mLamp = timeup_;
			}
		}
	}
}

void fSTOPTIM_mLamp (struct tTMEL_mLamp *timer_, struct tTMQE_mLamp *timeup_)
{
	if (timer_->set_)
	{
		--TIMING_mLamp.set_;
	}
	timer_->set_ = FALSE;
	if (tuhead_mLamp == timeup_)
	{
		tuhead_mLamp = tuhead_mLamp->next_;
	}
	if (timeup_->preced_)
	{
		timeup_->preced_->next_ = timeup_->next_;
	}
	if (timeup_->next_)
	{
		timeup_->next_->preced_ = timeup_->preced_;
	}
	if (tutail_mLamp == timeup_)
	{
		tutail_mLamp = timeup_->preced_;
	}
	timeup_->preced_ = 0;
	timeup_->next_ = 0;
}

/* Control Functions */

	/* Step Function for CIP Machine */

void fSTEP_(void)
{
	if (tuhead_mLamp != 0)
	{
		TIMING_mLamp.tuhndl_();
	}
	return;
}

	/* Chain Function for CIP Machine */

void fCHAIN_(void)
{
	return;
}

	/* Timeup Function for CIP Machine */

void fTIMEUP_(void)
{
	if (tuhead_mLamp != 0)
	{
		TIMING_mLamp.tuhndl_();
	}
	return;
}

	/* Read Function for CIP Machine */

void fREAD_(void)
{
	return;
}


/* Initialization Function */

int fINIT_(void)
{
	tuhead_mLamp = tutail_mLamp = 0;
	TRG_.TICK_ = fTICK_;
	TRG_.CHAIN_ = fCHAIN_;
	TRG_.TIMEUP_ = fTIMEUP_;
	TRG_.STEP_ = fSTEP_;
	TRG_.READ_ = fREAD_;
	TRG_.AUTO_ = fAUTOHDL_;
	IN_.Button = fICHAN_Button;
	iCHAN_();
	if (!OUT_.Lamp)
	{
		return 0;
	}
	fINIT_Button ();
	fINIT_Lamp ();
	return 1;
}

/*********************************************************************
	End of Module for CIP MACHINE mLamp
*********************************************************************/

// Actifsource ID=[a9fcef86-9d17-11e1-90e4-e1fd5739c0f6,c78073c1-af0f-11e1-8e28-c3261f5498f2,4971106d-af26-11e1-8e28-c3261f5498f2,ba697f7b-2723-11e1-b14b-53cb3f44a5b8,49794dd6-af26-11e1-8e28-c3261f5498f2,4977c731-af26-11e1-8e28-c3261f5498f2,zWydZPzW+pPEaKpliSfa89NiWIk=]
