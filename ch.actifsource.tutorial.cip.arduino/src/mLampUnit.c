/*********************************************************************
	SYSTEM LampSystem
	IMPLEMENTATION LampImplementation
	Module for CIP MACHINE mLampUnit
	Filename: mLampUnit.c
	generated by CIP Tool(R)
	
	activated code options:
		C code
		use message interface
			naming option: use default prefix
		use postfix
			LampUnit 
		enable PENDING_ information
		incremental build
		'unsigned char' for delays
*********************************************************************/

/* Include Files */

#include "mLampUnit.h"

/* External Declarations */

void fIMSG_C1_Push(void);
void fIMSG_C1_Release(void);
void fINIT_Button (void);
void fINIT_Lamp (void);

/* Global Declarations */

unsigned char time_LampUnit = 0;
struct tCHNOUT_mLampUnit CHNOUT_mLampUnit;
struct tTIMING_mLampUnit TIMING_mLampUnit[TIMER_COUNT_LampUnit];
struct tTMQE_mLampUnit *tuhead_mLampUnit, *tutail_mLampUnit;

/* Function Prototypes */

void fSETTIM_mLampUnit (unsigned char *delay_, struct tTMEL_mLampUnit *timer_, struct tTMQE_mLampUnit *timeup_);
void fSTOPTIM_mLampUnit (struct tTMEL_mLampUnit *timer_, struct tTMQE_mLampUnit *timeup_);
void fSTEP_LampUnit(void);
void fCHAIN_LampUnit(void);
void fTIMEUP_LampUnit(void);
void fREAD_LampUnit(void);
void fUPDATE_LampCluster (void);

/* AUTO_ Handler Function */

static void fAUTOHDL_LampUnit(void)
{
		/* dummy function handling no AUTO_ */
}

/* Timer Functions */

static void fTICK_LampUnit(void)
{
	int i_;
	++time_LampUnit;
	for (i_ = 0; i_ < 1; i_ ++)
	{
		if (TIMING_mLampUnit[i_].set_)
		{
			TIMING_mLampUnit[i_].tkhndl_();
		}
	}
	TRG_LampUnit.PENDING_.TIMEUP_ = tuhead_mLampUnit != 0;
	TRG_LampUnit.PENDING_.ANY_ = TRG_LampUnit.PENDING_.ANY_ || TRG_LampUnit.PENDING_.TIMEUP_;
}

void fSETTIM_mLampUnit (unsigned char *delay_, struct tTMEL_mLampUnit *timer_, struct tTMQE_mLampUnit *timeup_)
{
	if (*delay_ > 0)
	{
		if (!timer_->set_)
		{
			++TIMING_mLampUnit[timeup_->proctype_].set_;
		}
		timer_->set_ = TRUE;
		timer_->end_ = time_LampUnit + *delay_;
		if (tuhead_mLampUnit == timeup_)
		{
			tuhead_mLampUnit = tuhead_mLampUnit->next_;
		}
		if (timeup_->preced_)
		{
			timeup_->preced_->next_ = timeup_->next_;
		}
		if (timeup_->next_)
		{
			timeup_->next_->preced_ = timeup_->preced_;
		}
		if (tutail_mLampUnit == timeup_)
		{
			tutail_mLampUnit = timeup_->preced_;
		}
		timeup_->preced_ = 0;
		timeup_->next_ = 0;
	}
	else 
	{
		if (timer_->set_)
		{
			--TIMING_mLampUnit[timeup_->proctype_].set_;
		}
		timer_->set_ = FALSE;
		if (tuhead_mLampUnit != timeup_ && ! timeup_->preced_ && ! timeup_->next_)
		{
			if (!tuhead_mLampUnit)
			{
				tuhead_mLampUnit = tutail_mLampUnit = timeup_;
			}
			else 
			{
				tutail_mLampUnit->next_ = timeup_;
				timeup_->preced_ = tutail_mLampUnit;
				tutail_mLampUnit = timeup_;
			}
		}
	}
}

void fSTOPTIM_mLampUnit (struct tTMEL_mLampUnit *timer_, struct tTMQE_mLampUnit *timeup_)
{
	if (timer_->set_)
	{
		--TIMING_mLampUnit[timeup_->proctype_].set_;
	}
	timer_->set_ = FALSE;
	if (tuhead_mLampUnit == timeup_)
	{
		tuhead_mLampUnit = tuhead_mLampUnit->next_;
	}
	if (timeup_->preced_)
	{
		timeup_->preced_->next_ = timeup_->next_;
	}
	if (timeup_->next_)
	{
		timeup_->next_->preced_ = timeup_->preced_;
	}
	if (tutail_mLampUnit == timeup_)
	{
		tutail_mLampUnit = timeup_->preced_;
	}
	timeup_->preced_ = 0;
	timeup_->next_ = 0;
}

/* Control Functions */

	/* Step Function for CIP Machine */

void fSTEP_LampUnit(void)
{
	if (tuhead_mLampUnit != 0)
	{
		TIMING_mLampUnit[tuhead_mLampUnit->proctype_].tuhndl_();
	}
	return;
}

	/* Chain Function for CIP Machine */

void fCHAIN_LampUnit(void)
{
	return;
}

	/* Timeup Function for CIP Machine */

void fTIMEUP_LampUnit(void)
{
	if (tuhead_mLampUnit != 0)
	{
		TIMING_mLampUnit[tuhead_mLampUnit->proctype_].tuhndl_();
	}
	return;
}

	/* Read Function for CIP Machine */

void fREAD_LampUnit(void)
{
	return;
}

/* Update Functions */

void fUPDATE_LampCluster (void)
{
	TRG_LampUnit.PENDING_.TIMEUP_ = tuhead_mLampUnit != 0;
	TRG_LampUnit.PENDING_.ANY_ = 
		TRG_LampUnit.PENDING_.TIMEUP_;
}

/* Initialization Function */

int fINIT_LampUnit(void)
{
	tuhead_mLampUnit = tutail_mLampUnit = 0;
	TRG_LampUnit.TICK_ = fTICK_LampUnit;
	TRG_LampUnit.CHAIN_ = fCHAIN_LampUnit;
	TRG_LampUnit.TIMEUP_ = fTIMEUP_LampUnit;
	TRG_LampUnit.STEP_ = fSTEP_LampUnit;
	TRG_LampUnit.READ_ = fREAD_LampUnit;
	TRG_LampUnit.AUTO_ = fAUTOHDL_LampUnit;
	TRG_LampUnit.PENDING_.ANY_ = 0;
	TRG_LampUnit.PENDING_.CHAIN_ = 0;
	TRG_LampUnit.PENDING_.TIMEUP_ = 0;
	TRG_LampUnit.PENDING_.READ_ = 0;
	TRG_LampUnit.PENDING_.AUTO_ = 0;
	IN_LampUnit.C1_Push = fIMSG_C1_Push;
	IN_LampUnit.C1_Release = fIMSG_C1_Release;
	iMSG_LampUnit();
	if (!OUT_LampUnit.C2_Bright)
	{
		return 0;
	}
	if (!OUT_LampUnit.C2_Dark)
	{
		return 0;
	}
	fINIT_Button ();
	fINIT_Lamp ();
	return 1;
}

/*********************************************************************
	End of Module for CIP MACHINE mLampUnit
*********************************************************************/

/* Actifsource ID=[a9fcef86-9d17-11e1-90e4-e1fd5739c0f6,2898f6c0-ef75-11ef-aef2-9dc0ca6165d0,2898f67e-ef75-11ef-aef2-9dc0ca6165d0,2898f6d3-ef75-11ef-aef2-9dc0ca6165d0,2898f6bf-ef75-11ef-aef2-9dc0ca6165d0,2898f6be-ef75-11ef-aef2-9dc0ca6165d0,t+cGNQeFSqXapzNshBSA+1X6G+0=] */
