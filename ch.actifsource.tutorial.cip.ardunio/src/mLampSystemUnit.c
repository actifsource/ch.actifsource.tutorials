/*********************************************************************
	SYSTEM LampSystem
	IMPLEMENTATION LampSystemImplementation
	Module for CIP MACHINE mLampSystemUnit
	Filename: mLampSystemUnit.c
	generated by CIP Tool(R)
	
	activated code options:
		C code
		use message interface
			naming option: use default prefix
		use postfix
			LampSystemUnit 
		enable PENDING_ information
		'unsigned char' for delays
*********************************************************************/

/* Include Files */

#include "mLampSystemUnit.h"

/* External Declarations */

void fIMSG_C1_Press(void);
void fIMSG_C1_Release(void);
void fINIT_Button (void);
void fINIT_Lamp (void);

/* Global Declarations */

unsigned char time_LampSystemUnit = 0;
struct tCHNOUT_mLampSystemUnit CHNOUT_mLampSystemUnit;
struct tTIMING_mLampSystemUnit TIMING_mLampSystemUnit;
struct tTMQE_mLampSystemUnit *tuhead_mLampSystemUnit, *tutail_mLampSystemUnit;

/* Function Prototypes */

void fSETTIM_mLampSystemUnit (unsigned char *delay_, struct tTMEL_mLampSystemUnit *timer_, struct tTMQE_mLampSystemUnit *timeup_);
void fSTOPTIM_mLampSystemUnit (struct tTMEL_mLampSystemUnit *timer_, struct tTMQE_mLampSystemUnit *timeup_);
void fSTEP_LampSystemUnit(void);
void fCHAIN_LampSystemUnit(void);
void fTIMEUP_LampSystemUnit(void);
void fREAD_LampSystemUnit(void);
void fUPDATE_LampCluster (void);

/* AUTO_ Handler Function */

static void fAUTOHDL_LampSystemUnit(void)
{
		/* dummy function handling no AUTO_ */
}

/* Timer Functions */

static void fTICK_LampSystemUnit(void)
{
	++time_LampSystemUnit;
	if (TIMING_mLampSystemUnit.set_)
	{
		TIMING_mLampSystemUnit.tkhndl_();
	}
	TRG_LampSystemUnit.PENDING_.TIMEUP_ = tuhead_mLampSystemUnit != 0;
	TRG_LampSystemUnit.PENDING_.ANY_ = TRG_LampSystemUnit.PENDING_.ANY_ || TRG_LampSystemUnit.PENDING_.TIMEUP_;
}

void fSETTIM_mLampSystemUnit (unsigned char *delay_, struct tTMEL_mLampSystemUnit *timer_, struct tTMQE_mLampSystemUnit *timeup_)
{
	if (*delay_ > 0)
	{
		if (!timer_->set_)
		{
			++TIMING_mLampSystemUnit.set_;
		}
		timer_->set_ = TRUE;
		timer_->end_ = time_LampSystemUnit + *delay_;
		if (tuhead_mLampSystemUnit == timeup_)
		{
			tuhead_mLampSystemUnit = tuhead_mLampSystemUnit->next_;
		}
		if (timeup_->preced_)
		{
			timeup_->preced_->next_ = timeup_->next_;
		}
		if (timeup_->next_)
		{
			timeup_->next_->preced_ = timeup_->preced_;
		}
		if (tutail_mLampSystemUnit == timeup_)
		{
			tutail_mLampSystemUnit = timeup_->preced_;
		}
		timeup_->preced_ = 0;
		timeup_->next_ = 0;
	}
	else 
	{
		if (timer_->set_)
		{
			--TIMING_mLampSystemUnit.set_;
		}
		timer_->set_ = FALSE;
		if (tuhead_mLampSystemUnit != timeup_ && ! timeup_->preced_ && ! timeup_->next_)
		{
			if (!tuhead_mLampSystemUnit)
			{
				tuhead_mLampSystemUnit = tutail_mLampSystemUnit = timeup_;
			}
			else 
			{
				tutail_mLampSystemUnit->next_ = timeup_;
				timeup_->preced_ = tutail_mLampSystemUnit;
				tutail_mLampSystemUnit = timeup_;
			}
		}
	}
}

void fSTOPTIM_mLampSystemUnit (struct tTMEL_mLampSystemUnit *timer_, struct tTMQE_mLampSystemUnit *timeup_)
{
	if (timer_->set_)
	{
		--TIMING_mLampSystemUnit.set_;
	}
	timer_->set_ = FALSE;
	if (tuhead_mLampSystemUnit == timeup_)
	{
		tuhead_mLampSystemUnit = tuhead_mLampSystemUnit->next_;
	}
	if (timeup_->preced_)
	{
		timeup_->preced_->next_ = timeup_->next_;
	}
	if (timeup_->next_)
	{
		timeup_->next_->preced_ = timeup_->preced_;
	}
	if (tutail_mLampSystemUnit == timeup_)
	{
		tutail_mLampSystemUnit = timeup_->preced_;
	}
	timeup_->preced_ = 0;
	timeup_->next_ = 0;
}

/* Control Functions */

	/* Step Function for CIP Machine */

void fSTEP_LampSystemUnit(void)
{
	if (tuhead_mLampSystemUnit != 0)
	{
		TIMING_mLampSystemUnit.tuhndl_();
	}
	return;
}

	/* Chain Function for CIP Machine */

void fCHAIN_LampSystemUnit(void)
{
	return;
}

	/* Timeup Function for CIP Machine */

void fTIMEUP_LampSystemUnit(void)
{
	if (tuhead_mLampSystemUnit != 0)
	{
		TIMING_mLampSystemUnit.tuhndl_();
	}
	return;
}

	/* Read Function for CIP Machine */

void fREAD_LampSystemUnit(void)
{
	return;
}

/* Update Functions */

void fUPDATE_LampCluster (void)
{
	TRG_LampSystemUnit.PENDING_.TIMEUP_ = tuhead_mLampSystemUnit != 0;
	TRG_LampSystemUnit.PENDING_.ANY_ = 
		TRG_LampSystemUnit.PENDING_.TIMEUP_;
}

/* Initialization Function */

int fINIT_LampSystemUnit(void)
{
	tuhead_mLampSystemUnit = tutail_mLampSystemUnit = 0;
	TRG_LampSystemUnit.TICK_ = fTICK_LampSystemUnit;
	TRG_LampSystemUnit.CHAIN_ = fCHAIN_LampSystemUnit;
	TRG_LampSystemUnit.TIMEUP_ = fTIMEUP_LampSystemUnit;
	TRG_LampSystemUnit.STEP_ = fSTEP_LampSystemUnit;
	TRG_LampSystemUnit.READ_ = fREAD_LampSystemUnit;
	TRG_LampSystemUnit.AUTO_ = fAUTOHDL_LampSystemUnit;
	TRG_LampSystemUnit.PENDING_.ANY_ = 0;
	TRG_LampSystemUnit.PENDING_.CHAIN_ = 0;
	TRG_LampSystemUnit.PENDING_.TIMEUP_ = 0;
	TRG_LampSystemUnit.PENDING_.READ_ = 0;
	TRG_LampSystemUnit.PENDING_.AUTO_ = 0;
	IN_LampSystemUnit.C1_Press = fIMSG_C1_Press;
	IN_LampSystemUnit.C1_Release = fIMSG_C1_Release;
	iMSG_LampSystemUnit();
	if (!OUT_LampSystemUnit.C2_Dark)
	{
		return 0;
	}
	if (!OUT_LampSystemUnit.C2_Bright)
	{
		return 0;
	}
	fINIT_Button ();
	fINIT_Lamp ();
	return 1;
}

/*********************************************************************
	End of Module for CIP MACHINE mLampSystemUnit
*********************************************************************/

// Actifsource ID=[a9fcef86-9d17-11e1-90e4-e1fd5739c0f6,47a975e5-45f8-11e2-a9e9-277eb93c19ba,534e318e-45fa-11e2-a9e9-277eb93c19ba,7884c17a-45fb-11e2-a9e9-277eb93c19ba,53507b87-45fa-11e2-a9e9-277eb93c19ba,534f9122-45fa-11e2-a9e9-277eb93c19ba,n/YOrhBVQiQfHhnipmmMWDbgfnA=]
